#include "book_management.h"
#include <stdio.h>
#include <string.h>
static BookArray book_array;
static int book_array_size = 0;
File *book_file = null;
//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books(FILE *file) {
    Book *p = book_array.array;
    int len = book_array.length;
    Book book;
    if((file = fopen(file, "w")) == NULL) {
        printf("file open error.\n");
        exit(0);
    }

    while (len--) {
        fwrite(p, sizeof(Book), 1, file);
        ++p;
    }
	fclose(fp);
}

//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE *file) {
    Book book;
    Book *p = book_array.array;
    if((file = fopen("test", "r")) == NULL) {
        printf("file open error.\n");
        exit(0);
    }
    //获取有多少种书
    int cnt = 0;

    while(NULL != fread(book, sizeof(Book), 1, file)) {

    }
}

//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book) {
    const int book_array_step = 10;

    if (book_array.length + 1 > book_array_size) {
        if ((book_array.array = realloc(book_array.array, book_array_size + book_array_step * sizeof(struct Book))) == NULL) {
            printf("malloc error!\n");
            exit(0);
        }
        book_array_size += book_array_step;
    }

    book_array.array[book_array.length++] = book;
    book_array.array = (Book*)malloc(sizeof(Book) * (book_array.length + 1));

    return 0;
}

//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book);

//finds books with a given title.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.

int get_bookArray(BookArray ba, Book b) {
    Book book;

    if ((ba.array = realloc(book_array.array, book_array_size + sizeof(struct Book))) == NULL) {
        printf("malloc error!\n");
        exit(0);
    }

    ba.array[ba.length].authors = b.authors;
    ba.array[ba.length].copies = b.copies;
    ba.array[ba.length].id = b.id;
    ba.array[ba.length].title = b.title;
    ba.array[ba.length].year = b.year;


    book_array.array[book_array.length++] = book;
    book_array.array = (Book*)malloc(sizeof(Book) * (book_array.length + 1));

    return 0;
}

BookArray find_book_by_title (const char *title) {
    BookArray ba = BookArray(NULL, 0);
    for (int i = 0; i < book_array.length; ++i) {
        if (!strcmp(book_array.array[i].title, title)) {
            if (!get_bookArray(ba, book_array.array[i]))
        }
    }
    return ba;
}

//finds books with the given authors.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_author (const char *author) {
    BookArray ba = BookArray(NULL, 0);
    for (int i = 0; i < book_array.length; ++i) {
        if (!strcmp(book_array.array[i].authors, author)) {
            if (!get_bookArray(ba, book_array.array[i]))
        }
    }
    return ba;
}

//finds books published in the given year.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_year (unsigned int year) {
    BookArray ba = BookArray(NULL, 0);
    for (int i = 0; i < book_array.length; ++i) {
        if (book_array.array[i].year == year) {
            if (!get_bookArray(ba, book_array.array[i]))
        }
    }
    return ba;
}

